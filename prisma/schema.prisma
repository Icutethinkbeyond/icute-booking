datasource db {
  provider = "mongodb"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

model User {

  userId     String     @id @default(auto()) @map("_id") @db.ObjectId
  email      String
  password   String?
  name       String
  userStatus UserStatus @default(ACTIVE)

  role       Role?      @relation(fields: [roleId], references: [roleId])
  roleId     String?    @db.ObjectId

  store       Store?    

  createdAt DateTime    @default(now())
  updatedAt DateTime    @updatedAt

  @@index([email])

}

enum UserStatus {
  ACTIVE
  INACTIVE
}

model Role {

  roleId      String   @id @default(auto()) @map("_id") @db.ObjectId
  name        RoleName
  description String?
  users       User[]
  userIds     String[] @db.ObjectId
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@unique([name])

}

enum RoleName {
  ADMIN
  STOREADMIN
}

model Customer {
  
  id             String      @id @default(auto()) @map("_id") @db.ObjectId

  // 2. LINE Login Data
  // lineUserId คือ ID หลักที่ได้จาก LINE ใช้สำหรับส่ง Push Message และต้องไม่ซ้ำกัน
  lineUserId     String     @unique 
  displayName    String?    // ชื่อที่ LINE ตั้งไว้ (Nullable)
  pictureUrl     String?    // URL รูปโปรไฟล์ (Nullable)
  statusMessage  String?    // สถานะข้อความ (Nullable)
  isLineLinked   Boolean    @default(true) // ยืนยันว่าผูก LINE แล้ว

  // 3. Contact Data - ข้อมูลติดต่อที่ได้จากการจอง
  phone          String?    // เบอร์โทรศัพท์ (Nullable)
  email          String?    // อีเมล (Nullable)

  booking       Booking[]
  
  // 4. Metadata
  createdAt      DateTime   @default(now())
  updatedAt      DateTime   @updatedAt // อัปเดตวันที่เองเมื่อมีการแก้ไข Record

  // (Optional) หากมีตารางจอง (Booking) ให้เพิ่มความสัมพันธ์
  // bookings      Booking[] // ตัวอย่างความสัมพันธ์ 1:N 
  
  // @@map("customers") // กำหนดชื่อตารางใน Database
}

// model Report {

//   id         String     @id @default(auto()) @map("_id") @db.ObjectId
//   reportDate DateTime   @db.Date             // วันที่ของรายงาน
//   reportType String     // เช่น "Daily", "Monthly"
//   totalBookings Int
//   totalRevenue  Float
//   details      Json     // ข้อมูลละเอียด เช่น { "serviceA": 10, "serviceB": 5 }
//   generatedAt  DateTime   @default(now())
  
//   storeId    String     @db.ObjectId
//   store      Store      @relation(fields: [storeId], references: [id])
  
//   @@unique([storeId, reportDate, reportType])
// }


enum BookingStatus {
  PENDING    // รอลูกค้ายืนยัน (ถ้ามี), หรือรอยืนยันจากร้าน (ถ้าตั้งค่าไว้)
  CONFIRMED  // ยืนยันแล้ว (จองสำเร็จ)
  RESCHEDULED // เลื่อนนัด
  CANCELLED  // ยกเลิก
  COMPLETED  // เสร็จสิ้นบริการ
  WALK_IN    // คิว Walk-in (2.4)
}


model Booking {

  id              String          @id @default(auto()) @map("_id") @db.ObjectId
  customerName    String          // 3.6
  customerPhone   String          // 3.6
  
  startTime       DateTime        // 3.5 วัน-เวลาเริ่ม
  endTime         DateTime        // คำนวณจาก startTime + Service.durationMinutes
  
  status          BookingStatus   @default(CONFIRMED) // 2.7, 2.8, 2.9
  isWalkIn        Boolean         @default(false)     // 2.4 เพิ่มคิว walk-in
  
  // ความสัมพันธ์
  storeId         String          @db.ObjectId
  store           Store           @relation(fields: [storeId], references: [id])
  
  serviceId       String          @db.ObjectId
  service         Service         @relation(fields: [serviceId], references: [id])
  
  employeeId      String          @db.ObjectId
  employee        Employee        @relation(fields: [employeeId], references: [id])

  customerId      String          @db.ObjectId
  customer        Customer        @relation(fields: [customerId], references: [id])

  notifications    Notification[] // เชื่อมกับ Notification

  // 2.12 ระบบกันคิวซ้ำ: ต้องใช้ Logic ใน Application หรือใช้ Unique Index แบบ Compound 
  // (แต่ MongoDB/Prisma ไม่รองรับ unique index บน DateTime ในรูปแบบที่ซับซ้อนสำหรับการจองซ้อน) 
  // จึงควรจัดการที่ Application Logic เมื่อสร้าง/แก้ไข Booking
  // อย่างไรก็ตาม การรวม employeeId, startTime เป็น unique index อาจช่วยได้ในระดับหนึ่ง
  @@index([employeeId, startTime]) // ช่วยในการตรวจสอบคิวซ้ำ/ค้นหาคิว

  // 3.7 ข้อความ LINE ส่งไปหาลูกค้า (ต้องใช้ Logic ใน Application)

  createdAt DateTime @default(now()) // วันที่สร้าง
  updatedAt DateTime @updatedAt // อัปเดตล่าสุด

  
}


model Service {

  id             String    @id @default(auto()) @map("_id") @db.ObjectId
  name           String    // "ตัดผม 30 นาที", "นวดตัว 1 ชม."
  durationMinutes Int      // ระยะเวลาเป็นนาที เช่น 30, 60
  price          Float?    // ราคา (ถ้ามี)

  // ความสัมพันธ์
  storeId        String    @db.ObjectId
  store          Store     @relation(fields: [storeId], references: [id])
  employees      Employee[] @relation(references: [id], fields: [employeeIds]) // พนักงานที่ทำบริการนี้ได้
  employeeIds    String[]  @db.ObjectId // Reference IDs
  bookings       Booking[]

  createdAt DateTime @default(now()) // วันที่สร้าง
  updatedAt DateTime @updatedAt // อัปเดตล่าสุด

}

model Employee {
  id             String    @id @default(auto()) @map("_id") @db.ObjectId
  name           String    // "พี่แอน"
  role           String    // "ช่างทำผม"
  isActive       Boolean   @default(true) // สถานะพร้อมให้บริการ
  
  // ความสัมพันธ์
  storeId        String    @db.ObjectId
  store          Store     @relation(fields: [storeId], references: [id])
  bookings       Booking[] // คิวที่พนักงานคนนี้รับผิดชอบ
  services       Service[] @relation(references: [id], fields: [serviceIds]) // บริการที่พนักงานคนนี้ทำได้
  serviceIds     String[]  @db.ObjectId // Reference IDs

  userId    String     @db.ObjectId


  createdAt DateTime @default(now()) // วันที่สร้าง
  updatedAt DateTime @updatedAt // อัปเดตล่าสุด
}

model OperatingHour {
  id        String     @id @default(auto()) @map("_id") @db.ObjectId
  date      DateTime   @db.Date
  isOpen    Boolean    @default(true) // true = เปิด, false = ปิด (วันหยุดพิเศษ)
  openTime  String?    // "09:00" ถ้า isOpen = true
  closeTime String?    // "18:00" ถ้า isOpen = true
  
  storeId   String     @db.ObjectId
  store     Store      @relation(fields: [storeId], references: [id])

  @@unique([storeId, date]) // ไม่ให้ตั้งค่าเวลาทำการซ้ำวัน

  createdAt DateTime @default(now()) // วันที่สร้าง
  updatedAt DateTime @updatedAt // อัปเดตล่าสุด
}

model Store {

  id               String            @id @default(auto()) @map("_id") @db.ObjectId
  storeName        String
  storeUsername    String            @unique 
  // bookingLink      String            @unique // 3.2 ลิงก์ร้านค้า
  // 2.1 กำหนดวันหยุด (วันหยุดประจำสัปดาห์ เช่น [1, 7] = จันทร์, อาทิตย์)
  weeklyHolidays   Int[]
  // 2.1 เวลาเปิด-ปิดต่อวัน (สำหรับวันทำงาน)
  defaultOpenTime  String            // "09:00"
  defaultCloseTime String            // "18:00"

  lineNotifyToken  String?     // 2.6 สำหรับการแจ้งเตือนเจ้าของร้าน
  lineChannelId    String?     // สำหรับ LINE Messaging API (ถ้าใช้)
  lineChannelSecret String?    // สำหรับ LINE Messaging API (ถ้าใช้)

  userId    String              @db.ObjectId @unique
  user      User                @relation(fields: [userId], references: [userId])

  // ความสัมพันธ์
  employees        Employee[]
  services         Service[]
  bookings         Booking[]
  operatingHours   OperatingHour[]   // เวลาเปิด-ปิด/วันหยุดพิเศษ
  notifications    Notification[] // เชื่อมกับ Notification
  // reports          Report[]

  createdAt DateTime @default(now()) // วันที่สร้าง
  updatedAt DateTime @updatedAt // อัปเดตล่าสุด
}

enum NotificationType {
  // สำหรับร้านค้า (Store)
  STORE_NEW_BOOKING       // 2.7 มีการจองใหม่
  STORE_CANCELED_BY_CUSTOMER
  STORE_BOOKING_MODIFIED

  // สำหรับลูกค้า (Customer)
  CUSTOMER_BOOKING_SUCCESS  // 3.7 จองสำเร็จ
  CUSTOMER_CONFIRMED      // 2.9 ร้านยืนยันคิว
  CUSTOMER_RESCHEDULED    // 2.8, 2.9 ร้านเลื่อน
  CUSTOMER_CANCELED       // 2.8, 2.9 ร้านยกเลิก
}

enum SendMethod {
  LINE_NOTIFY             // สำหรับแจ้งเตือนร้านค้า (ใช้ Store.lineNotifyToken)
  LINE_MESSAGING_API      // สำหรับแจ้งเตือนลูกค้า (ต้องมี User's LINE ID)
  EMAIL                   // 2.10 แจ้งเตือนในอีเมล
}

model Notification {
  id         String             @id @default(auto()) @map("_id") @db.ObjectId
  
  // ข้อมูลที่จำเป็นในการส่ง
  type       NotificationType
  method     SendMethod         // วิธีการส่ง: LINE/EMAIL
  message    String             // ข้อความที่จะส่ง
  targetAddress String          // เบอร์โทร/อีเมลลูกค้า, หรือ Store ID (สำหรับ LINE Notify)
  
  // สถานะการส่ง
  isSent     Boolean            @default(false)
  sentAt     DateTime?
  errorMessage String?          // เก็บ error ถ้าส่งไม่สำเร็จ
  
  // การอ้างอิง
  storeId    String             @db.ObjectId
  store      Store              @relation(fields: [storeId], references: [id])
  
  bookingId  String?            @db.ObjectId
  booking    Booking?           @relation(fields: [bookingId], references: [id])
  
  // เพิ่มเติม: สำหรับลูกค้าที่ใช้ LINE Messaging API 
  // (ถ้ามีการเชื่อมต่อ LINE OA และเก็บ User ID)
  lineUserId String?           
}